
################################################
#  "Somewhat standard imports for volatility"  #
################################################
from volatility3.framework import exceptions, renderers, interfaces, constants
from volatility3.framework.configuration import requirements
from volatility3.framework.renderers import format_hints, conversion

# Plugin imports
from volatility3.plugins.windows import pslist

# Other imports
import yara



class SearchScanner(interfaces.layers.ScannerInterface):
    _version = (1, 0, 0)

    # yara.Rules isn't exposed, so we can't type this properly
    def __init__(self, rules):
        super().__init__()
        if rules is None:
            raise ValueError("No rules provided to YaraScanner")
        self._rules = rules

    def __call__(self, data, data_offset):
        for match in self._rules.match(data = data):
            for offset, name, value in match.strings:
                yield (offset + data_offset, value.decode('utf-8'))



class find_string(interfaces.plugins.PluginInterface):

    # Volatility gets angry if you do not specify a framework version
    _required_framework_version = (1, 2, 0)

    @classmethod
    def get_requirements(cls):
        """
        A must have function for which volatility will create the necessary
        configs for this class
        """

        return [
            requirements.ModuleRequirement(name = 'kernel', description = 'Windows kernel',
                                           architectures = ["Intel32", "Intel64"]),

            requirements.PluginRequirement(name = 'pslist',
                                           plugin =  pslist.PsList,
                                           version = (2, 0, 0)),

            requirements.StringRequirement(name = 'search',
                                           description = "The string that you want to find"),
        ]


    def _generator(self):
        """
        This function is the main boi
    
        Whatever data you want to parse and all do it here.
        
        at the end you'll need to yield it.

        Make sure you yield it in the same format as you specified in run    
        """

        search_string = f'"{self.config["search"]}"'

        rules = yara.compile(sources = {'n': f'rule r1 {{strings: $a = {search_string} condition: $a}}'})

        # Set up the kernel
        kernel = self.context.modules[self.config['kernel']]

        # loop through each tasks
        for task in pslist.PsList.list_processes(context = self.context,
                                                 layer_name = kernel.layer_name,
                                                 symbol_table = kernel.symbol_table_name):

            layer_name = task.add_process_layer()
            layer = self.context.layers[layer_name]

            for offset, value in layer.scan(context = self.context,
                                            scanner = SearchScanner(rules = rules)):

                proc_name = task.ImageFileName.cast("string", max_length = task.ImageFileName.vol.count)

                yield(0, (format_hints.Hex(offset), proc_name, value))


    def run(self):
        """
        This function is called when you run this plugin.
        This is the one that creates the data to be printed

        It returns a TreeGrid which comes in the form of:
            - a list specifying the title
            - the data which is generated by _generator
        """

        return renderers.TreeGrid(
            [
                ("Offset", format_hints.Hex),
                ("Process Name", str),
                ("Value", str)
            ],
            self._generator()
        )